#!/bin/bash
# Environment variables supported:
# - MARIADB_CS_POSTCFG_INPUT - if set runs postConfigure with the value piped into stdin
# - MARIADB_DATABASE - if set create a database with this name

# file used to track / record initialization and prevent subsequent rerun
FLAG=/usr/local/mariadb/columnstore/etc/container-initialized
# directory which can contain sql, sql.gz, and sh scripts that will be run
# after successful initialization.
INITDIR=/docker-entrypoint-initdb.d
MCSDIR=/usr/local/mariadb/columnstore
mysql=( $MCSDIR/mysql/bin/mysql --defaults-extra-file=$MCSDIR/mysql/my.cnf -uroot )

# usage: file_env VAR [DEFAULT]
#    ie: file_env 'XYZ_DB_PASSWORD' 'example'
# (will allow for "$XYZ_DB_PASSWORD_FILE" to fill in the value of
#  "$XYZ_DB_PASSWORD" from a file, especially for Docker's secrets feature)
file_env() {
    local var="$1"
    local fileVar="${var}_FILE"
    local def="${2:-}"
    if [ "${!var:-}" ] && [ "${!fileVar:-}" ]; then
        echo >&2 "error: both $var and $fileVar are set (but are exclusive)"
        exit 1
    fi
    local val="$def"
    if [ "${!var:-}" ]; then
        val="${!var}"
    elif [ "${!fileVar:-}" ]; then
        val="$(< "${!fileVar}")"
    fi
    export "$var"="$val"
    unset "$fileVar"
}

# wait for the ProcMon process to start
wait_for_procmon()
{
    ATTEMPT=1
    MAX_TRIES=72
    if [ ! -z "$CS_WAIT_ATTEMPTS" ]; then
        MAX_TRIES=$(($CS_WAIT_ATTEMPTS*2))
    fi
    ps -e | grep ProcMon
    while [ 0 -ne $? ] && [ $ATTEMPT -le $MAX_TRIES ]; do
        if [ ! -z $CS_DEBUG ]; then
            echo "wait_for_procmon($ATTEMPT/$MAX_TRIES)"
        fi
        sleep 1
        ATTEMPT=$(($ATTEMPT+1))
        ps -e | grep ProcMon
    done
    
    ps -e | grep ProcMon
    if [ 0 -ne $? ]; then
        echo "ERROR: Failed to start the ProcMon process. Tried $ATTEMPT attempts."
        exit 1
    fi
}

# additional wait check to ensure postConfigure is fully done and complete
wait_for_postcfg_done()
{
    ATTEMPT=1
    MAX_TRIES=36
    if [ ! -z "$CS_WAIT_ATTEMPTS" ]; then
        MAX_TRIES=$CS_WAIT_ATTEMPTS
    fi
    FULLY_CONFIGURED=$( $MCSDIR/bin/getConfig Installation FullyConfigured )
    while [ 0 -eq $? ] && [ $ATTEMPT -le $MAX_TRIES ]; do
        if [ ! -z $CS_DEBUG ]; then
            echo "wait_for_postcfg_done($ATTEMPT/$MAX_TRIES): FullyConfigured: $FULLY_CONFIGURED"
        fi
        if [ "$FULLY_CONFIGURED" = "Y" ]; then
            echo "Detected postConfigure complete as Installation. FullyConfigured: $FULLY_CONFIGURED"
            break
        fi
        sleep 2
        ATTEMPT=$(($ATTEMPT+1)) FULLY_CONFIGURED=$( $MCSDIR/bin/getConfig Installation FullyConfigured )
    done

    if [ "$FULLY_CONFIGURED" != "Y" ]; then
        echo "ERROR: Failed to detect postConfigure complete as Installation.FullyConfigured: $FULLY_CONFIGURED"
        exit 1
    fi
}
# hack to ensure server-id is set to unique value per vm because my.cnf is
# not in a good location for a volume
SERVER_ID=$(hostname -i | cut -d "." -f 4)
SERVER_SUBNET=$(hostname -i | cut -d "." -f 1-3 -s)
sed -i "s/server-id =.*/server-id = $SERVER_ID/" /usr/local/mariadb/columnstore/mysql/my.cnf

# hack to make master-dist rsync.sh script do nothing as it fails otherwise
# in non distributed on windows and mac (occasionally on ubuntu).
# Replicating the db directories is a no-op here anyway
mv /usr/local/mariadb/columnstore/bin/rsync.sh /usr/local/mariadb/columnstore/bin/rsync.sh.bkp
touch /usr/local/mariadb/columnstore/bin/rsync.sh
chmod a+x /usr/local/mariadb/columnstore/bin/rsync.sh


# hack to specify user env var as this is sometimes relied on to detect
# root vs non root install
export USER=root

# Initialize CS only once.
if [ -e $FLAG ]; then
    echo "Container already initialized at $(date)"
else
    # wait for ProcMon to startup
    echo "Initializing container at $(date) - waiting for ProcMon to start"
    wait_for_procmon

    # Starting with 1.2, syslog setup is done in post-install during image
    # build. For some reason it's necessary to restart rsyslogd on first run
    # to get logging going
    /usr/sbin/sv restart rsyslogd

    # first time install with MARIADB_CS_POSTCFG_INPUT set then run postConfigure
    # with this as input. Must stop columnstore service first as postConfigure
    # will fail otherwise. The service is only used for restarted pm1 containers
    # or non pm1 containers in a cluster.
    # Support backward compat with CS_POSTCFG_INPUT
    MARIADB_CS_POSTCFG_INPUT="${MARIADB_CS_POSTCFG_INPUT:-$CS_POSTCFG_INPUT}"
    if [ ! -z "$MARIADB_CS_POSTCFG_INPUT" ]; then
        echo "Stopping columnstore service to run postConfigure"
        /usr/sbin/sv stop columnstore
        echo -e "$MARIADB_CS_POSTCFG_INPUT" | $MCSDIR/bin/postConfigure -n
        # Set a columnstore.xml property that can be used to detect postConfigure
        # complete from other nodes (as the change is pushed out)
        if [ 0 -eq $? ]; then
            $MCSDIR/bin/setConfig Installation FullyConfigured Y
        else
            echo "ERROR: postConfigure crashed with exit code $?"
            exit 1
        fi
    else
        # wait columnstore to startup by some other means
        echo "Waiting for columnstore to start to run post install files"
        /usr/sbin/wait_for_columnstore_active
        if [ 1 -eq $? ]; then
            # exit now if columnstore did not start
            echo "ERROR: ColumnStore did not start so custom install files not run."
            exit 1
        fi
        wait_for_postcfg_done
    fi

    # allow deletion of local users on non um1 with seperate  env var
    if [ ! -z "$MARIADB_DROP_LOCAL_USERS" ]; then
        "${mysql[@]}" 2>&1 << EOSQL
                  SET @@SESSION.SQL_LOG_BIN=0;
                  DELETE FROM mysql.user WHERE user = '';
EOSQL
    fi
    
    MYSQLDS_RUNNING=$(ps -ef | grep -v grep | grep mysqld | wc -l)
    if [ $MYSQLDS_RUNNING -gt 0 ]; then
        # only perform user setup / creation of one of the root password env vars
        if  [ ! -z "$MARIADB_ROOT_PASSWORD" -o ! -z "$MARIADB_ALLOW_EMPTY_PASSWORD" -o ! -z "$MARIADB_RANDOM_ROOT_PASSWORD" ]; then
            if [ ! -z "$MARIADB_RANDOM_ROOT_PASSWORD" ]; then
                export MARIADB_ROOT_PASSWORD="$(/usr/bin/pwgen -1 32)"
                echo "GENERATED MARIADB ROOT PASSWORD: $MARIADB_ROOT_PASSWORD"
            fi

            # create root user, default listens from anywhere
            file_env 'MARIADB_ROOT_HOST' '%'
            if [ ! -z "$MARIADB_ROOT_HOST" -a "$MARIADB_ROOT_HOST" != 'localhost' ]; then
                read -r -d '' rootCreate << EOSQL || true
                    CREATE USER 'root'@'${MARIADB_ROOT_HOST}' IDENTIFIED BY '${MARIADB_ROOT_PASSWORD}' ;
                    GRANT ALL ON *.* TO 'root'@'${MARIADB_ROOT_HOST}' WITH GRANT OPTION ;
EOSQL
            fi

            # pull this out seperately since the host specific users on um1 don't
            # exist on other UM's and will fail replication.
           "${mysql[@]}" 2>&1 << EOSQL
                SET @@SESSION.SQL_LOG_BIN=0;
                DELETE FROM mysql.user WHERE user = '';
                DELETE FROM mysql.user WHERE password = '' AND host <> 'localhost';  
EOSQL
           "${mysql[@]}" 2>&1 << EOSQL
                SET PASSWORD FOR 'root'@'localhost'=PASSWORD('${MARIADB_ROOT_PASSWORD}') ;
                GRANT ALL ON *.* TO 'root'@'localhost' WITH GRANT OPTION ;
                ${rootCreate}
                DROP DATABASE IF EXISTS test ;
EOSQL

            if [ ! -z "$MARIADB_ROOT_PASSWORD" ]; then
                mysql+=( -p"${MARIADB_ROOT_PASSWORD}" )
            fi

            # Create custom database if specified. CS_DATABASE for backward compat
            MARIADB_DATABASE="${MARIADB_DATABASE:-$CS_DATABASE}"
            if [ ! -z "$MARIADB_DATABASE" ]; then
                        "${mysql[@]}" 2>&1 -e "CREATE DATABASE IF NOT EXISTS \`$MARIADB_DATABASE\`;"
                  mysql+=( "$MARIADB_DATABASE" )
            fi
        fi
        
        file_env 'MARIADB_USER'
        file_env 'MARIADB_PASSWORD'
        if [ "$MARIADB_USER" -a "$MARIADB_PASSWORD" ]; then
            "${mysql[@]}" 2>&1 << EOSQL
                CREATE USER '$MARIADB_USER'@'%' IDENTIFIED BY '$MARIADB_PASSWORD' ;
                CREATE USER '$MARIADB_USER'@'localhost' IDENTIFIED BY '$MARIADB_PASSWORD' ;
                GRANT CREATE TEMPORARY TABLES ON infinidb_vtable.* to '$MARIADB_USER'@'%' ;
                GRANT CREATE TEMPORARY TABLES ON infinidb_vtable.* to '$MARIADB_USER'@'localhost' ;
EOSQL

            if [ "$MARIADB_DATABASE" ]; then
                "${mysql[@]}" -e "GRANT ALL ON \`$MARIADB_DATABASE\`.* TO '$MARIADB_USER'@'%' ;"  2>&1
                "${mysql[@]}" -e "GRANT ALL ON \`$MARIADB_DATABASE\`.* TO '$MARIADB_USER'@'localhost' ;"  2>&1
            fi
        fi
    fi
    
    WRK_DIR=`pwd`
    # Check number of custom install files and execute them 
    CUSTOM_INSTALL_FILES=$(ls $INITDIR/*.{sql,sql.gz,sh} -la 2>/dev/null | wc -l)
    if [ ! -z $MARIADB_CS_DEBUG ]; then
        echo "$CUSTOM_INSTALL_FILES custom files"
    fi
    # check for any custom post install sql or shell scripts to run in INITDIR
    if [ 0 -eq $CUSTOM_INSTALL_FILES ]; then
        echo "No custom post install files to run at $(date)"
    else
        echo "Executing custom post install files at $(date)"
        cd /docker-entrypoint-initdb.d/
        for f in $(ls $INITDIR/); do
            if [[ $f == *.sql ]];then
                echo "Run $f at $(date)"
                "${mysql[@]}" -vvv < $f 2>&1
                if [ 0 -ne $? ]; then
                    echo "Script $f failed, aborting setup"
                    exit 1
                fi
            elif [[ $f == *.sql.gz ]];then
                echo "Run $f at $(date)"
                zcat $f | "${mysql[@]}" -vvv  2>&1
                if [ 0 -ne $? ]; then
                    echo "Script $f failed, aborting setup"
                    exit 1
                fi
            elif [[ $f == *.sh ]]; then
                chmod 755 $f
                echo "Run $f at $(date)"
                if [ -z $MARIADB_CS_DEBUG ]; then
                    /bin/sh $f 2>&1
                else
                    /bin/sh -x $f 2>&1
                fi
                if [ 0 -ne $? ]; then
                    echo "Script $f failed, aborting setup"
                    exit 1
                fi
            fi;
        done;
    fi
    cd $WRK_DIR
    unset MARIADB_ROOT_PASSWORD
    echo "Container initialization complete at $(date)"
    touch $FLAG
fi
exit 0;
